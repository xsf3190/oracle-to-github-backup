CREATE OR REPLACE EDITIONABLE PACKAGE "PCK_DEPLOY" as 
    --
    PROCEDURE deleteDirectory(pWebsiteId IN website.id%type, pUserId IN users.id%type);
    --
    PROCEDURE deployInfrastructure;
    --
    PROCEDURE deployWebsite(pBodyText IN CLOB);
    --
    PROCEDURE updateDeploymentStatus(pWebsiteId IN website.id%type, pBodyText IN CLOB);
    --
    PROCEDURE logDeployment(pBodyText IN CLOB, pWebsiteId IN website.id%type);
    --
    PROCEDURE runDeployment(pWebsiteId IN website.id%type, pUserId IN website.user_id%type, pSiteId IN website.netlify_site_id%type) ;
    --
end;
/
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PCK_DEPLOY" as 
    
    /*
    ** Build and deploy website to Netlify by submitting Github action
    */    
    PROCEDURE deployWebsite(pBodyText IN CLOB) IS
        l_clob CLOB;
        l_blob BLOB;

        l_job_name VARCHAR2(30);
        n PLS_INTEGER;
        l_body_text CLOB:=pBodyText;
        l_website_id website.id%type;
        l_site_id website.netlify_site_id%type;
        l_session_data pck_core.session_data_rt;
    BEGIN
        l_session_data:=pck_core.getSessionData();

        SELECT websiteid, siteid INTO l_website_id, l_site_id FROM users, JSON_TABLE(l_body_text, '$' COLUMNS (websiteid, siteid)) WHERE users.id=l_session_data.user_id;

        /* Check no other session currently deploying */

        FOR C IN (SELECT job_name FROM user_scheduler_running_jobs WHERE job_name LIKE 'DEPLOY_%') LOOP
            logDeployment('{"site_id":"' || l_site_id || '","status":"Someone else is deploying ... try again later","exitcode":1}',l_website_id);
            apex_json.open_object;
            apex_json.write('success', TRUE);
            apex_json.close_object;
            RETURN;
        END LOOP;


        DELETE website_deploy WHERE website_id=l_website_id AND site_id=l_site_id;

        logDeployment('{"site_id":"' || l_site_id || '","status":"Preparing Deployment"}',l_website_id);

        l_job_name:=dbms_scheduler.generate_job_name('DEPLOY_');
        dbms_scheduler.create_job(
            job_name   => l_job_name,
            job_type   =>'STORED_PROCEDURE',
            job_action =>'pck_deploy.runDeployment',
            number_of_arguments=>3,
            start_date=>systimestamp
        );
        dbms_scheduler.set_job_argument_value(
            job_name => l_job_name,
            argument_position => 1,
            argument_value => l_website_id
        );
        dbms_scheduler.set_job_argument_value(
            job_name => l_job_name,
            argument_position => 2,
            argument_value => l_session_data.user_id
        );
        dbms_scheduler.set_job_argument_value(
            job_name => l_job_name,
            argument_position => 3,
            argument_value => l_site_id
        );
        dbms_scheduler.enable(l_job_name);

        apex_json.open_object; 
        apex_json.write('success', TRUE);
        apex_json.close_object;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;

    /*
    **  DEPLOY BY UPLOADING HTML FILE CONTENT DIRECTLY TO NETLIFY
    */
    PROCEDURE runDeployment(pWebsiteId IN website.id%type, pUserId IN website.user_id%type, pSiteId IN website.netlify_site_id%type) IS
        l_clob CLOB;
        l_json JSON_OBJECT_T;
        l_files JSON_OBJECT_T;
        l_page CLOB;
        l_file_name website_article.navigation_label%type;
        l_sha1 VARCHAR2(40);
        TYPE tt_files IS RECORD (
            lastmod article.updated_date%type,
            url VARCHAR2(200),
            file_name website_article.navigation_label%type,
            file_content CLOB
        );
        TYPE t_files IS TABLE OF tt_files INDEX BY VARCHAR2(40);
        l_deploy_files t_files;

        TYPE tt_labels IS RECORD (
            article_id website_article.article_id%type,
            navigation_label website_article.navigation_label%type,
            path website_article.navigation_label%type
        );
        TYPE t_labels IS TABLE OF tt_labels INDEX BY PLS_INTEGER;
        l_labels t_labels;

        l_sitemap CLOB;
        l_robots CLOB;
        l_ssl_url VARCHAR2(200);
        n PLS_INTEGER:=0;

        FUNCTION buildNavLabels(pArticleId IN website_article.article_id%type) RETURN VARCHAR2 IS
            l_nav LONG;
        BEGIN
            FOR i IN 1..l_labels.COUNT LOOP
                l_nav:=l_nav || '<a href="/' || CASE WHEN i>1 THEN l_labels(i).path END || '" class="nav-label' 
                            || CASE WHEN l_labels(i).article_id=pArticleId THEN ' selected' END || '" data-id="' || l_labels(i).article_id || '">' || l_labels(i).navigation_label || '</a>';
            END LOOP;
            RETURN (l_nav);
        END;

        FUNCTION contactEmail RETURN VARCHAR2 IS
            l_contact_email website.contact_email%type;
        BEGIN
            SELECT contact_email INTO l_contact_email FROM website WHERE id=pWebsiteId;
            IF (l_contact_email IS NULL) THEN
                SELECT email INTO l_contact_email FROM users WHERE id=pUserId;
            END IF;
            RETURN (l_contact_email);
        END;

    BEGIN
        SELECT article_id, navigation_label, apex_string_util.get_slug(navigation_label) path  
        BULK COLLECT INTO l_labels
        FROM website_article 
        WHERE website_id=pWebsiteId 
        ORDER BY display_order;


        /* Get URL of site to be deployed in order to build navigation links */
        pck_api.callNetlifyAPI(pUserId=>pUserId, pEndpoint=>'sites/' || pSiteId, pMethod=>'GET', pData=>l_clob);
        SELECT ssl_url INTO l_ssl_url FROM JSON_TABLE(l_clob, '$' COLUMNS(ssl_url));

        /* Get SHA1 of all files to be deployed */
        l_json:= new JSON_OBJECT_T;
        l_files:= new JSON_OBJECT_T;

        FOR C IN (SELECT w.domain_name, w.css, w.javascript, 
                         wa.article_id, wa.page_title, wa.page_description, apex_string_util.get_slug(wa.navigation_label) path_name, wa.contact_form,
                         COALESCE(a.updated_date,a.created_date) lastmod, a.body_html, 
                         u.name, ROW_NUMBER() OVER (ORDER BY wa.display_order) rn, COUNT(*) OVER () nb
                    FROM website w, website_article wa, article a, users u
                   WHERE w.id=pWebsiteId
                     AND wa.website_id=w.id
                     AND wa.article_id=a.id
                     AND u.id=w.user_id
                   ORDER BY wa.display_order)
        LOOP
            l_page:='<!DOCTYPE HTML>' || chr(10) ||
                    '<html lang="en">' || chr(10) ||
                    '<head>' || chr(10) ||
                        '<meta charset="UTF-8">' || chr(10) ||
                        '<meta name="viewport" content="width=device-width, initial-scale=1.0">' || chr(10) || 
                        '<title>' || C.page_title || '</title>' || chr(10) ||
                        '<meta name="description" content=">' || C.page_description || '">' || chr(10) ||
                        '<meta name="author" content=">' || C.name || '">' || chr(10) ||
                        '<link rel="icon" href="https://res.cloudinary.com/mrbapex/believeintalking_favicon_q57es4.svg" type="image/svg+xml">'  || chr(10) ||
                        '<style>' || C.css || chr(10) || '</style>' || chr(10) || 
                    '</head>' || chr(10) || 
                    '<body>' || CASE WHEN c.nb>1 THEN '<nav aria-label="Main Navigation">' || buildNavLabels(C.article_id) || '</nav>' END || chr(10) || 
                        REPLACE(C.body_html,'<h1>&nbsp;</h1>',null) || chr(10) || 
                        CASE WHEN C.contact_form='YES' THEN pck_core.buildContactForm(contactEmail()) END ||
                        '<!-- Hidden input fields identify performance data sent to database -->
                        <input type="hidden" name="visit_url" value="' || pck_core.getRestUrl || 'page-visit"/>
                        <input type="hidden" name="website_id" value="' || pWebsiteId || '"/>
                        <input type="hidden" name="article_id" value="' || C.article_id || '"/>
                        <script>
                        const vitalsQueue = new Set(),
                              mediaQueue = new Set();
                        const addToVitalsQueue = (metric) => {
                            console.log(metric.name,metric.value);
                            vitalsQueue.add(metric);
                        };
                        </script>
                        <script type="module">
                            import {onCLS, onFID, onLCP, onINP} from ''https://unpkg.com/web-vitals?module'';
                            onCLS(addToVitalsQueue);
                            onFID(addToVitalsQueue);
                            onLCP(addToVitalsQueue);
                            onINP(addToVitalsQueue);
                        </script>
                        <script>' || C.javascript || '</script>' || chr(10) || '
                     </body>' || chr(10) || 
                    '</html>';

            l_sha1:=LOWER(dbms_crypto.hash(src => l_page, typ => dbms_crypto.hash_sh1));
            l_file_name:=CASE WHEN C.rn=1 THEN 'index' ELSE NVL(C.path_name,'Page_'||C.rn) END || '.html';

            l_deploy_files(l_sha1).url:='https://www.' || C.domain_name || CASE WHEN C.rn>1 THEN '/' || NVL(C.path_name,'Page_'||C.rn) END;
            l_deploy_files(l_sha1).lastmod:=C.lastmod;
            l_deploy_files(l_sha1).file_name:=l_file_name;
            l_deploy_files(l_sha1).file_content:=l_page;
            l_files.put(l_file_name, l_sha1);
        END LOOP;

        /* Build sitemap.xml */

        l_sitemap:='<?xml version="1.0" encoding="UTF-8"?>' || chr(10) || 
                    '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">' || chr(10);

        l_sha1:=l_deploy_files.FIRST;
        WHILE (l_sha1 IS NOT NULL) LOOP
            IF (l_sha1=l_deploy_files.FIRST) THEN
                l_robots:='User-agent: *' || chr(10) || 'Allow: /' || chr(10) || chr(10) || 'Sitemap: ' || l_deploy_files(l_sha1).url || '/sitemap.xml';
            END IF;
            l_sitemap:=l_sitemap || 
                '    <url>' || chr(10) || 
                '        <loc>' || l_deploy_files(l_sha1).url || '</loc>' || chr(10) || 
                '        <lastmod>' || TO_CHAR(l_deploy_files(l_sha1).lastmod,'YYYY-MM-DD') || '</lastmod>' || chr(10) || 
                '    </url>' || chr(10);
            l_sha1 := l_deploy_files.NEXT(l_sha1);
        END LOOP;
        l_sitemap:=l_sitemap || '</urlset>';

        l_sha1:=LOWER(dbms_crypto.hash(src => l_sitemap, typ => dbms_crypto.hash_sh1));
        l_deploy_files(l_sha1).file_name:='sitemap.xml';
        l_deploy_files(l_sha1).file_content:=l_sitemap;
        l_files.put('sitemap.xml', l_sha1);

        l_sha1:=LOWER(dbms_crypto.hash(src => l_robots, typ => dbms_crypto.hash_sh1));
        l_deploy_files(l_sha1).file_name:='robots.txt';
        l_deploy_files(l_sha1).file_content:=l_robots;
        l_files.put('robots.txt', l_sha1);

        l_json.put('files',l_files);

        pck_api.callNetlifyAPI(pUserId=>pUserId, pEndpoint=>'sites/' || pSiteId || '/deploys', pMethod=>'POST', pBody=>l_json.stringify, pData=>l_clob);
        pck_core.log(l_clob);

        /* upload to Netlify if required - i.e. file content has changed since last deployment  */

        FOR C IN (SELECT id, sha1 FROM JSON_TABLE(l_clob, '$' COLUMNS (id, NESTED '$.required[*]' COLUMNS (sha1 PATH '$'))) WHERE sha1 IS NOT NULL) LOOP
            logDeployment('{"site_id":"' || pSiteId || '","status":"Uploading ' || l_deploy_files(C.sha1).file_name || '"}',pWebsiteId);
            pck_api.callNetlifyAPI(pUserId=>pUserId, pEndpoint=>'deploys/' || C.id || '/files/' || l_deploy_files(C.sha1).file_name, pMethod=>'PUT', pBody=>l_deploy_files(C.sha1).file_content, pData=>l_clob);
        END LOOP;

        EXCEPTION
            WHEN OTHERS THEN
                logDeployment('{"site_id":"' || pSiteId || '","status":"' || SUBSTR(SQLERRM,1,100) || '", "exitcode": 1}',pWebsiteId);
                pck_core.log_error;
    END;

    /*
     **  Insert row in website_deploy logging table
     **  1) Invoked via curl from Github Action
     **  2) called internally within this package to log Netlify actions
     */      
    PROCEDURE logDeployment(pBodyText IN CLOB, pWebsiteId IN website.id%type) IS 
        l_site_id website_deploy.site_id%type;
        l_exitcode PLS_INTEGER;
        l_status website_deploy.status%type;
    BEGIN
        SELECT site_id, status, NVL(exitcode,0)
          INTO l_site_id, l_status, l_exitcode
          FROM JSON_TABLE(pBodyText, '$' COLUMNS (site_id, status, exitcode));

        INSERT INTO website_deploy(id, website_id, site_id, status) VALUES (seq_log.nextval, pWebsiteId, l_site_id, l_status || ' - ' || CASE WHEN l_exitcode=0 THEN 'OK' ELSE 'NOK' END);

        COMMIT;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;    


    /*
     **  Get deployment status from website_deploy logging table
     */
    PROCEDURE updateDeploymentStatus(pWebsiteId IN website.id%type, pBodyText IN CLOB) IS 
        l_site_id website_deploy.site_id%type;
        l_status CLOB;
        l_clob CLOB:=pBodyText;
        l_ssl_url VARCHAR2(100);
        l_deployment_complete BOOLEAN:=FALSE;
        l_netlify_status website_deploy.status%type;
        l_job_name VARCHAR2(30);
        l_session_data pck_core.session_data_rt;
    BEGIN
        l_session_data:=pck_core.getSessionData();

        SELECT site_id INTO l_site_id FROM JSON_TABLE(l_clob, '$' COLUMNS (site_id));

        /* Get latest deployment status */
        pck_api.callNetlifyAPI(pUserId=>l_session_data.user_id, pEndpoint=>'sites/'|| l_site_id || '/deploys', pMethod=>'GET', pData=>l_clob);
        FOR C IN (SELECT state, ssl_url, error_message, created_at
                    FROM JSON_TABLE(l_clob, '$[0]' COLUMNS (state, ssl_url, created_at, error_message))) 
        LOOP
            IF (C.state='ready') THEN
                l_deployment_complete:=TRUE;
                l_ssl_url:=C.ssl_url;
            END IF;
            logDeployment('{"site_id":"' || l_site_id || '","status":"' || 'Status is ' || C.state || '","exitcode":' || CASE WHEN C.error_message IS NULL THEN 0 ELSE 1 END || '}',pWebsiteId);
        END LOOP;

        /* return list of all deployment status to client */
        FOR C IN (SELECT id, status, ROUND(EXTRACT (second FROM diff),1) ela_sec
                    FROM 
                        (
                         SELECT id, status, NVL(LEAD(log_time) OVER (ORDER BY id),current_timestamp) - log_time as diff
                           FROM website_deploy 
                          WHERE website_id=pWebsiteId
                            AND site_id=l_site_id
                        )
                   ORDER BY id) 
        LOOP
            l_status:=l_status || TO_CLOB('<span>' || C.status || ' - ' || C.ela_sec || ' seconds</span><br>');
            IF (SUBSTR(C.status,-3)='NOK') THEN
                l_deployment_complete:=TRUE;
                EXIT;
            END IF;
        END LOOP;

        IF (l_ssl_url IS NOT NULL) THEN
            FOR C IN (SELECT ROUND(EXTRACT (second FROM diff),1)  total_elapsed FROM 
                        (SELECT MAX(log_time)-MIN(log_time) as diff FROM website_deploy WHERE website_id=pWebsiteId AND site_id=l_site_id) )
            LOOP
                l_status:=l_status || TO_CLOB('<span>DEPLOYMENT COMPLETE  - ' || C.total_elapsed || ' seconds</span><br>');
            END LOOP;
            l_status:=l_status || TO_CLOB('<a target="_blank" href="' || l_ssl_url || '">' || l_ssl_url || '<a>');
        END IF;

        apex_json.open_object; 
        apex_json.write('success', TRUE);
        apex_json.write('completed', l_deployment_complete);
        apex_json.write('status', l_status);
        apex_json.close_object;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;   

    /*
    ** Delete Github build directory - have to delete files individually before Github removes directory
    */    
    PROCEDURE deleteDirectory(pWebsiteId IN website.id%type, pUserId IN users.id%type) IS
        l_clob CLOB;
        l_domain_name website.domain_name%type;
        l_github CLOB;
        l_json JSON_OBJECT_T;
    BEGIN
        SELECT domain_name INTO l_domain_name FROM website WHERE id=pWebsiteId;
        pck_api.callGithubAPI(pUserId=>pUserId, pEndpoint=>'contents/'||l_domain_name, pMethod=>'GET', pData=>l_clob);
        FOR C IN (SELECT name, sha, message FROM  JSON_TABLE(l_clob FORMAT JSON, '$[*]' COLUMNS (name, sha, message))) LOOP
            IF (C.message IS NOT NULL) THEN 
                pck_core.log(C.message);
                RAISE_APPLICATION_ERROR(-20050,'Error in deleteDirectory - '|| C.message);
            ELSE
                l_json:=JSON_OBJECT_T.parse('{"message":"Commit by PLSQL"}');
                l_json.put('sha',C.sha);
                l_github:=l_json.to_clob; 
                pck_api.callGithubAPI(pUserId=>pUserId, pEndpoint=>'contents/' || l_domain_name || '/'||C.name, pMethod=>'DELETE', pBody=>l_github, pData=>l_clob);
            END IF;
        END LOOP;
        pck_api.resetGithubCurrentBuild(pUserId);
    END;

    /*
    ** Build and deploy infrastructure through Terraform by submitting Github action. 
    ** Do this once and each time we recycle the public key that is used to sign a website's contact email
    */
    PROCEDURE deployInfrastructure IS
        l_clob CLOB;
        l_json_clob CLOB;
        l_json JSON_OBJECT_T;
        l_action JSON_OBJECT_T;
        l_session_data pck_core.session_data_rt;
    BEGIN
        l_session_data:=pck_core.getSessionData();

        FOR C IN (SELECT terraform_token, replace(utl_raw.cast_to_varchar2(utl_encode.base64_encode(utl_raw.cast_to_raw(terraform_public_key))),chr(13)||chr(10),null) terraform_public_key
                    FROM users
                   WHERE id=l_session_data.user_id) 
        LOOP
            /* trigger the deployment using Githib action */          
            l_json:=new JSON_OBJECT_T;
            l_json.put('event_type', 'trigger_build_infra');

            l_action:=new JSON_OBJECT_T;
            l_action.put('from_email', 'funnyface@markrussellbrown.com');
            l_action.put('public_key', C.terraform_public_key);
            l_action.put('terraform_token', C.terraform_token);
            l_json.put('client_payload', l_action);

            --l_clob := apex_web_service.make_rest_request(p_url=>'https://api.github.com/repos/'|| C.deploy_repo || '/dispatches' ,p_http_method=>'POST',p_body=>l_json.stringify);

            /* nb; Github API 'dispatches' endpoint does not send a response */
            l_json_clob:=l_json.stringify;
            pck_api.callGithubAPI(pUserId=>l_session_data.user_id, pEndpoint=>'dispatches', pMethod=>'POST', pBody=>l_json_clob, pData=>l_clob);

            apex_json.open_object; 
            apex_json.write('success', TRUE);
            apex_json.close_object;
        END LOOP;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;       
end;
/