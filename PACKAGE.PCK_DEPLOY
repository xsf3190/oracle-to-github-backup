CREATE OR REPLACE EDITIONABLE PACKAGE "PCK_DEPLOY" as 
    --
    PROCEDURE buildESModules(pEsmLibrary IN VARCHAR2 DEFAULT 'test');
    --
    PROCEDURE deleteDirectory(pWebsiteId IN website.id%type, pUserId IN users.id%type);
    --
    PROCEDURE deployInfrastructure(pSenderEmail IN VARCHAR2 DEFAULT 'contact.form');
    --
    PROCEDURE logDeployment(pWebsiteId IN website.id%type, pSiteId IN website_deploy.site_id%type, pMessage IN VARCHAR2, pStatus IN VARCHAR2 DEFAULT 'OK', pLogTime IN TIMESTAMP DEFAULT current_timestamp);
    --
    PROCEDURE runDelete(pUserId IN users.id%type, pWebsiteId IN website.id%type, pSiteId IN website.netlify_site_id%type);
    --
    PROCEDURE runDeployment(pWebsiteId IN website.id%type, pUserId IN website.user_id%type, pEnv IN VARCHAR2, pSiteId IN website.netlify_site_id%type, pRestUrl IN VARCHAR2, pEsmLibrary IN VARCHAR2);
    --
    PROCEDURE setTerraformApikey;
    --
end;
/
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PCK_DEPLOY" as 

    FUNCTION getSha256(pContent IN CLOB) RETURN VARCHAR2 IS
        l_sha256 RAW(92);
    BEGIN
        l_sha256:=dbms_crypto.hash(src=>pContent, typ=>dbms_crypto.hash_sh256);
        RETURN ('sha256-' || utl_raw.cast_to_varchar2(utl_encode.base64_encode(l_sha256)));
    END;
    
    /*
    ** SERVE JS AND CSS MODULES FROM NETLIFY SITE
    ** "TEST" - FOR TESTING BY ADMIN USERS OF ADMIN-oWNED WEBSITES
    ** "LIVE" - ALL DEPLOYED WEBSITES LINK TO THESE
    */
    PROCEDURE buildESModules(pEsmLibrary IN VARCHAR2) IS 
        TYPE tt_files IS RECORD (
            file_name apex_application_static_files.file_name%type,
            file_content CLOB
        );
        TYPE t_files IS TABLE OF tt_files INDEX BY VARCHAR2(40);
        l_deploy_files t_files;

        l_headers CLOB;
        l_files JSON_OBJECT_T;
        l_json JSON_OBJECT_T;

        l_sha1_test es_modules.sha1_test%type;
        l_sha256_test es_modules.sha256_test%type;
        
        l_page CLOB;
        l_table CLOB;
        
        l_clob CLOB;
        l_website_id website.id%type;
        l_netlify_site_id website.netlify_site_id%type;
        l_user_id website.user_id%type;
        l_ssl_url VARCHAR2(50);
        l_job_name VARCHAR2(30);
        l_netlify_deploy_id website.netlify_deploy_id%type;

        TYPE tt_websites IS RECORD (
            id website.id%type,
            user_id website.user_id%type,
            netlify_site_id website.netlify_site_id%type,
            netlify_site_id_custom website.netlify_site_id_custom%type
        );
        TYPE t_websites IS TABLE OF tt_websites INDEX BY PLS_INTEGER;
        l_websites t_websites;

    BEGIN
        IF (pEsmLibrary NOT IN ('test','live')) THEN
            RAISE_APPLICATION_ERROR(-20100,'Environment must be "live" or "test"');
            RETURN;
        END IF;

        SELECT id, netlify_site_id, user_id INTO l_website_id, l_netlify_site_id, l_user_id FROM website WHERE domain_name='es-modules';

        pck_api.callNetlifyAPI(pUserId=>null, pEndpoint=>'sites/' || l_netlify_site_id, pMethod=>'GET', pData=>l_clob);
        SELECT ssl_url INTO l_ssl_url FROM JSON_TABLE(l_clob, '$' COLUMNS(ssl_url));

        l_json:= new JSON_OBJECT_T;
        l_files:= new JSON_OBJECT_T;

        FOR C IN (
            SELECT s.file_name, SUBSTR(s.mime_type,INSTR(s.mime_type,'/')+1) || '/' file_path, CAST(s.last_updated_on AS TIMESTAMP WITH TIME ZONE) updated_source, apex_util.blob_to_clob(s.file_content) file_content, e.sha1_test, e.sha1_live
              FROM apex_application_static_files s, es_modules e
             WHERE s.file_name=e.module_name
               AND s.application_id=101
            )
        LOOP
            l_sha1_test:=LOWER(dbms_crypto.hash(src=>C.file_content, typ=>dbms_crypto.hash_sh1));
            l_sha256_test:=getSha256(C.file_content);

            IF (C.sha1_test IS NULL) THEN 
                INSERT INTO es_modules (
                    host_name, module_name, updated_source, sha1_test, sha256_test, updated_test, sha1_live, sha256_live, updated_live, live_change_ind) 
                VALUES (
                    l_ssl_url || '/live/' || C.file_path || C.file_name, 
                    C.file_name, 
                    C.updated_source, 
                    l_sha1_test, 
                    l_sha256_test, 
                    current_timestamp, 
                    l_sha1_test, 
                    l_sha256_test, 
                    current_timestamp,
                    0);
            ELSIF(l_sha1_test<>C.sha1_test) THEN 
                UPDATE es_modules
                   SET updated_source=C.updated_source,
                       sha1_test=l_sha1_test, 
                       sha256_test=l_sha256_test,
                       updated_test=current_timestamp
                 WHERE module_name=C.file_name;
            END IF;
            
            l_deploy_files(l_sha1_test).file_name:=C.file_path || C.file_name;
            l_deploy_files(l_sha1_test).file_content:=C.file_content;
            l_files.put('test/' || C.file_path || C.file_name, l_sha1_test);

            /*
            ** UPDATE "live" HASH VALUES TO THE ALWAYS CALCULATED TEST VALUES WHEN PARAMETER PASSED
            */
            IF (pEsmLibrary='live') THEN
                UPDATE es_modules
                   SET sha1_live=l_sha1_test,
                       sha256_live=l_sha256_test,
                       live_change_ind=CASE WHEN sha1_live=l_sha1_test THEN 0 ELSE 1 END,
                       updated_live=current_timestamp
                 WHERE module_name=C.file_name;
                l_files.put('live/' || C.file_path || C.file_name, l_sha1_test);
            ELSE
            /*
            ** ENSURE THAT ES_MODULES.NETLIFY.APP IS ALWAYS DEPLOYED INCLUDING "live" ESM FILES
            */
                l_files.put('live/' || C.file_path || C.file_name, NVL(C.sha1_live,l_sha1_test) );
            END IF;
            
        END LOOP;

        l_headers:='/*' || chr(10) || 'Access-Control-Allow-Origin: *' || chr(10) || 'Timing-Allow-Origin: *';
        l_sha1_test:=LOWER(dbms_crypto.hash(src=>l_headers, typ=>dbms_crypto.hash_sh1));
        l_deploy_files(l_sha1_test).file_name:='_headers';
        l_deploy_files(l_sha1_test).file_content:=l_headers;
        l_files.put('_headers', l_sha1_test);

        l_page:=
        '<!DOCTYPE HTML>' ||
        '<html lang="en">' ||
        '<head>' ||
            '<meta charset="UTF-8">' ||
            '<meta name="viewport" content="width=device-width, initial-scale=1.0">' ||
        '</head>' ||
        '<body>' ||
        '<h1>ES Modules deployed at' || to_char(sysdate,'dd.mm.yyyy hh24:mi') || '</h1>' || 
        '</body>' ||
        '</html>';
        l_sha1_test:=LOWER(dbms_crypto.hash(src=>l_page, typ=>dbms_crypto.hash_sh1));
        l_deploy_files(l_sha1_test).file_name:='index.html';
        l_deploy_files(l_sha1_test).file_content:=l_page;
        l_files.put('index.html', l_sha1_test);


        l_json.put('files',l_files);

        /*
        ** POST ALL FILE NAMES AND THEIR SHA1 VALUES TO THE NETLIFY DEPLOYS ENDPOINT
        ** - RETURNS ARRAY OF SHA1 TO BE UPLOADED 
        */

        pck_api.callNetlifyAPI(pUserId=>null, pEndpoint=>'sites/' || l_netlify_site_id || '/deploys', pMethod=>'POST', pBody=>l_json.stringify, pData=>l_clob);
        
        /*
        ** UPLOAD TO NETLIFY ALL FILES WITH UNIQUE CONTENT
        */
        FOR C IN (SELECT id, sha1 FROM JSON_TABLE(l_clob, '$' COLUMNS (id, NESTED '$.required[*]' COLUMNS (sha1 PATH '$'))) WHERE sha1 IS NOT NULL) LOOP
            l_netlify_deploy_id:=C.id;
            pck_core.log('... uploading ESM ' || l_deploy_files(C.sha1).file_name);
            pck_api.callNetlifyAPI(pUserId=>null, pEndpoint=>'deploys/' || C.id || '/files/' || l_deploy_files(C.sha1).file_name, pMethod=>'PUT', 
                pBody=>l_deploy_files(C.sha1).file_content,
                pData=>l_clob
            );
        END LOOP;

        UPDATE website SET netlify_deploy_id=l_netlify_deploy_id WHERE id=l_website_id;

        /*
        ** DELETE ANY MODULES For WHICH SOURCE NO LONGER EXISTS
        */
        DELETE es_modules WHERE module_name NOT IN (SELECT file_name FROM apex_application_static_files WHERE application_id=101);
        COMMIT;

        /*
        ** WAIT FOR DEPLOYMENT OF ES-MODULES TO COMPLETE
        */
        pck_hosting.waitDeployment(pWebsiteid=>l_website_id, pUserid=>l_user_id, pWaitSeconds=>10);

        /*
        ** DELETE OLD DEPLOYMENTS OF ES-MODULES.NETLIFY.APP
        */
        pck_deploy.runDelete(pUserId=>l_user_id, pWebsiteId=>l_website_id, pSiteId=>l_netlify_site_id);

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;

    /*
    **  Insert row in website_deploy logging table
    */      
    PROCEDURE logDeployment(pWebsiteId IN website.id%type, pSiteId IN website_deploy.site_id%type, pMessage IN VARCHAR2, pStatus IN VARCHAR2 DEFAULT 'OK', pLogTime IN TIMESTAMP DEFAULT current_timestamp) IS 
    BEGIN
        INSERT INTO website_deploy(id, website_id, site_id, message, status, log_time) VALUES (seq_log.nextval, pWebsiteId, pSiteId, pMessage, pStatus, pLogTime);
        COMMIT;
    END; 

    /* Return distict characters sorted */
    FUNCTION chars_used (pCharacters IN VARCHAR2) RETURN VARCHAR2 IS
        l_chars website_font.chars_normal%type;
    BEGIN
        SELECT LISTAGG(DISTINCT SUBSTR(pCharacters, LEVEL, 1), NULL) WITHIN GROUP (
                  ORDER BY SUBSTR(pCharacters, LEVEL, 1))
        INTO l_chars
        FROM dual
        CONNECT BY LEVEL <= LENGTH(pCharacters);
        RETURN(l_chars);
    END;

    /* 
    ** EXTRACT DISTINCT ITALIC / NORMAL / BOLD CHARACTERS IN TEXT
    */
    PROCEDURE extract_styles(pText IN VARCHAR2, pBoldItalic IN OUT VARCHAR2, pBoldNormal IN OUT VARCHAR2, pItalic IN OUT VARCHAR2, pNormal IN OUT VARCHAR2,
        pBoldItalicPage IN OUT PLS_INTEGER, pBoldNormalPage IN OUT PLS_INTEGER, pItalicPage IN OUT PLS_INTEGER, pNormalPage IN OUT PLS_INTEGER) IS
        l_text LONG:=pText;
        l_italics_regex varchar2(12):='<i>(.+?)</i>';
        l_italics_substr LONG;
        l_italics_bold_regex varchar2(30):='<i><strong>(.+?)</strong></i>';
        l_italics_bold_substr LONG;
        l_bold_regex varchar2(30):='<strong>(.+?)</strong>';
        l_bold_substr LONG;
        l_char VARCHAR2(4);
        n PLS_INTEGER;
        len PLS_INTEGER;
    BEGIN
        IF (pText IS NULL) THEN
            RETURN;
        END IF;
        n:=REGEXP_COUNT(l_text,l_italics_bold_regex);
        FOR i IN 1..n LOOP
            l_italics_bold_substr:=utl_i18n.unescape_reference(apex_escape.striphtml(REGEXP_SUBSTR(l_text,l_italics_bold_regex,1,i)));
            len:=LENGTH(l_italics_bold_substr);
            IF (len>0) THEN
                pBoldItalicPage:=pBoldItalicPage+1;
                FOR k IN 1..len LOOP
                    l_char:=SUBSTR(l_italics_bold_substr,k,1);
                    IF (pBoldItalic IS NULL OR INSTR(pBoldItalic,l_char)=0) THEN
                        pBoldItalic:=pBoldItalic || l_char;
                    END IF;
                END LOOP;
            END IF;
        END LOOP;

        l_text:=REGEXP_REPLACE(l_text,l_italics_bold_regex,null);

        n:=REGEXP_COUNT(l_text,l_italics_regex);
        FOR i IN 1..n LOOP
            l_italics_substr:=utl_i18n.unescape_reference(apex_escape.striphtml(REGEXP_SUBSTR(l_text,l_italics_regex,1,i)));
            len:=LENGTH(l_italics_substr);
            IF (len>0) THEN
                pItalicPage:=pItalicPage+1;
                FOR k IN 1..len LOOP
                    l_char:=SUBSTR(l_italics_substr,k,1);
                    IF (pItalic IS NULL OR INSTR(pItalic,l_char)=0) THEN
                        pItalic:=pItalic || l_char;
                    END IF;
                END LOOP;
            END IF;
        END LOOP;

        l_text:=REGEXP_REPLACE(l_text,l_italics_regex,null);

        n:=REGEXP_COUNT(l_text,l_bold_regex);
        FOR i IN 1..n LOOP
            l_bold_substr:=utl_i18n.unescape_reference(apex_escape.striphtml(REGEXP_SUBSTR(l_text,l_bold_regex,1,i)));
            len:=LENGTH(l_bold_substr);
            IF (len>0) THEN
                pBoldNormalPage:=pBoldNormalPage+1;
                FOR k IN 1..len LOOP
                    l_char:=SUBSTR(l_bold_substr,k,1);
                    IF (pBoldNormal IS NULL OR INSTR(pBoldNormal,l_char)=0) THEN
                        pBoldNormal:=pBoldNormal || l_char;
                    END IF;
                END LOOP;
            END IF;
        END LOOP;

        l_text:=REGEXP_REPLACE(l_text,l_bold_regex,null);

        l_text:=utl_i18n.unescape_reference(apex_escape.striphtml(l_text));
        len:=LENGTH(l_text);
        
        IF (len>0) THEN
            pNormalPage:=pNormalPage+1;
            FOR i IN 1..len LOOP
                l_char:=SUBSTR(l_text,i,1);
                IF (pNormal IS NULL OR INSTR(pNormal,l_char)=0) THEN
                    pNormal:=pNormal || l_char;
                END IF;
            END LOOP;
        END IF;
    END;

    /*
    ** ADJUST <img> ELEMENTS TO INCLUDE SRCSET WITH SIZES="ANY"
    */
    PROCEDURE setImgSrcset(pArticleid IN article.id%type, pHeroAssetid IN website.hero_asset_id%type, pImgCount IN OUT PLS_INTEGER, pBodyHtml IN OUT NOCOPY article.body_html%type) IS
        l_img_regex varchar2(50):='("https://res.cloudinary.com(.+?)")';
        l_img_src VARCHAR2(2000);
        l_srcset VARCHAR2(2000);
        l_public_id asset.public_id%type;
        n PLS_INTEGER;
    BEGIN
        -- ONLY DO THIS IF IMAGE FORMATS ARE AVIF
        SELECT COUNT(*) INTO n FROM dual WHERE EXISTS (SELECT null FROM asset WHERE article_id=pArticleid AND format='avif');
        IF (n=0) THEN 
            RETURN;
        END IF;

        pImgCount:=REGEXP_COUNT(pBodyHtml,l_img_regex);
        n:=pImgCount;

        IF (n=0) THEN 
            RETURN;
        END IF;

        -- APPEND srcset attribute to <img> element. "alt" attribute is entered by user in editor

        FOR i IN 1..n LOOP
            l_img_src:=REGEXP_SUBSTR(pBodyHtml,l_img_regex,1,i);
            l_public_id:=RTRIM(SUBSTR(l_img_src,INSTR(l_img_src,'/',-1)+1),'"');
            FOR C IN (
                SELECT cld_cloud_name, breakpoints FROM asset WHERE article_id=pArticleid AND public_id=l_public_id
            ) LOOP
                FOR C1 IN (SELECT column_value AS breakpoint FROM TABLE(apex_string.split(C.breakpoints,','))) LOOP
                    l_srcset:=l_srcset || 'https://res.cloudinary.com/' || C.cld_cloud_name || '/w_' || C1.breakpoint || '/' || l_public_id || ' ' || C1.breakpoint || 'w,';
                END LOOP;
                l_srcset:=RTRIM(l_srcset,',');
            END LOOP;
            l_img_src:=l_img_src || ' sizes="10vw" srcset="' || l_srcset || '"';
            IF (pHeroAssetid IS NOT NULL) THEN
                l_img_src:=l_img_src || ' loading="lazy"';
            ELSIF (i>1) THEN
                l_img_src:=l_img_src || ' loading="lazy"';
            END IF;
            pBodyHtml:=REGEXP_REPLACE(pBodyHtml,l_img_regex,l_img_src,1,i);
        END LOOP;
    END;

    /*
    **  DEPLOY BY UPLOADING HTML FILE CONTENT DIRECTLY TO NETLIFY
    */
    PROCEDURE runDeployment(pWebsiteId IN website.id%type, pUserId IN website.user_id%type, pEnv IN VARCHAR2, pSiteId IN website.netlify_site_id%type, pRestUrl IN VARCHAR2, pEsmLibrary IN VARCHAR2) IS
        
        l_clob CLOB;
        l_json JSON_OBJECT_T;
        l_files JSON_OBJECT_T;
        l_head CLOB;
        l_page CLOB;
        
        l_title website.title%type;
        l_subtitle website.subtitle%type;
        l_contact_email website.contact_email%type;
        l_telephone_number website.telephone_number%type;
        l_mobile_number website.mobile_number%type;
        l_linkedin_name website.linkedin_name%type;
        l_instagram_name website.instagram_name%type;
        l_color_primary website.color_primary%type;
        l_favicon_asset_id website.favicon_asset_id%type;
        l_body_html article.body_html%type;
        l_favicon_url VARCHAR2(250);
        l_favicon_download BLOB;
        l_content CLOB;
        l_text VARCHAR2(4000);
        l_char VARCHAR2(4);
        l_css_updated_date website.updated_date%type;
        l_css_prev_updated_date website.updated_date%type;
        l_css_root website.css_root%type;
        l_css_root_prev website.css_root%type;
        l_file_name VARCHAR2(200);
        l_sha1 website_files.sha1%type;
        l_sha1_prev website_files.sha1%type;
        l_current_timestamp website_files.created_date%type;
        l_script_src VARCHAR2(500);
        
        l_code_regex varchar2(30):='<code(.+?)<\/code>';
        l_headings_regex varchar2(30):='<h[1-4]>(.+?)<\/h[1-4]>';
        l_src_url_regex varchar2(30):='url\(([^)]*)\';

         TYPE tt_fonts IS RECORD (
            font_id font.id%type,
            family font.family%type,
            wght_bold font.wght_end%type,
            wght_normal font.wght_end%type,
            prev_chars_normal VARCHAR2(500),
            prev_chars_italic VARCHAR2(500),
            prev_chars_bold_normal VARCHAR2(500),
            prev_chars_bold_italic VARCHAR2(500),
            chars_normal VARCHAR2(500),
            chars_italic VARCHAR2(500),
            chars_bold_normal VARCHAR2(500),
            chars_bold_italic VARCHAR2(500),
            chars_normal_page PLS_INTEGER,
            chars_italic_page PLS_INTEGER,
            chars_bold_normal_page PLS_INTEGER,
            chars_bold_italic_page PLS_INTEGER

        );
        TYPE t_fonts IS TABLE OF tt_fonts INDEX BY VARCHAR2(40);
        l_fonts t_fonts;

        l_context VARCHAR2(8);
        l_nb_fonts PLS_INTEGER;

        TYPE tt_files IS RECORD (
            file_name VARCHAR2(200),
            file_content CLOB,
            file_content_b BLOB,
            md5 VARCHAR2(32),
            content_length NUMBER
        );
        TYPE t_files IS TABLE OF tt_files INDEX BY VARCHAR2(40);
        l_deploy_files t_files;

        TYPE tt_labels IS RECORD (
            parent_article_id website_article.article_id%type,
            article_id website_article.article_id%type,
            --navigation_label article.title%type,  -- largest that can fit here
            path_name VARCHAR2(200),
            collection_type website_article.collection_type%type,
            page_title website_article.page_title%type,
            page_description website_article.page_description%type,
            lastmod article.updated_date%type,
            word_count article.word_count%type, 
            title website.title%type,
            subtitle website.subtitle%type,
            header_effect website.header_effect%type,
            hero_asset_id website.hero_asset_id%type,
            contact_email website.contact_email%type,
            telephone_number website.telephone_number%type,
            mobile_number website.mobile_number%type,
            linkedin_name website.linkedin_name%type,
            instagram_name website.instagram_name%type,
            promotion website.promotion%type,
            img_count PLS_INTEGER,
            font_preload VARCHAR2(1000),
            body_html article.body_html%type
        );
        TYPE t_labels IS TABLE OF tt_labels INDEX BY PLS_INTEGER;
        l_labels t_labels;

        l_is_media BOOLEAN:=FALSE;
        l_is_blog BOOLEAN:=FALSE;
        l_is_product BOOLEAN:=FALSE;

        l_deploy_env NUMBER;
        l_importmap  CLOB;
        l_importmap_integrity  CLOB;
        l_importmap_sha256 es_modules.sha256_live%type;

        l_message VARCHAR2(100);
        l_main_module  VARCHAR2(1000);
        l_script_sha256 VARCHAR2(500);
        l_css CLOB;
        l_css_minified CLOB;
        l_fontfaces CLOB;
        l_font_preload VARCHAR2(1000);
        l_styles_edit CLOB;
        
        l_sitemap CLOB;
        l_robots CLOB;
        l_headers CLOB;
        l_ssl_url VARCHAR2(200);
        l_url VARCHAR2(200);
        n PLS_INTEGER;

        l_dogface_requested CLOB;
        l_dogface_required CLOB;
        l_dogface_endpoint VARCHAR2(200);
        l_dogface_empty_clob CLOB:=EMPTY_CLOB();
        l_dogface_empty_blob BLOB:=EMPTY_BLOB();

        /* CLOB SIGNATURE */
        PROCEDURE addDeploy(pFilename IN VARCHAR2, pFileContent IN OUT NOCOPY CLOB) IS
        BEGIN
            l_sha1:=LOWER(dbms_crypto.hash(src => pFileContent, typ => dbms_crypto.hash_sh1));
            l_deploy_files(l_sha1).file_name:=pFilename;
            l_deploy_files(l_sha1).file_content:=pFileContent;
            l_files.put(pFilename, l_sha1);
            IF (pEsmLibrary='test') THEN
                l_deploy_files(l_sha1).md5:=LOWER(dbms_crypto.hash(src => pFileContent, typ => dbms_crypto.hash_md5));
                l_deploy_files(l_sha1).content_length:=dbms_lob.getlength(pFileContent);
            END IF;
        END;

        /* BLOB SIGNATURE */
        PROCEDURE addDeploy(pFilename IN VARCHAR2, pFileContent IN OUT NOCOPY BLOB) IS
        BEGIN
            l_sha1:=LOWER(dbms_crypto.hash(src => pFileContent, typ => dbms_crypto.hash_sh1));
            l_deploy_files(l_sha1).file_name:=pFilename;
            l_deploy_files(l_sha1).file_content_b:=pFileContent;
            l_files.put(pFilename, l_sha1);
            IF (pEsmLibrary='test') THEN
                l_deploy_files(l_sha1).md5:=LOWER(dbms_crypto.hash(src => pFileContent, typ => dbms_crypto.hash_md5));
                l_deploy_files(l_sha1).content_length:=dbms_lob.getlength(pFileContent);
            END IF;
        END;

        FUNCTION getFontFilename(pFamily IN VARCHAR2, pItal IN VARCHAR2, pWght IN VARCHAR2) RETURN VARCHAR2 IS
        BEGIN
            RETURN('fonts/' || REPLACE(pFamily,' ','-') || '.' || pItal || '.' || pWght || '.woff2');
        END;

        /*
        ** GOOGLE FONTS SELF-HOSTED 
        */
        FUNCTION getFontface(pFamily IN VARCHAR2, pItal IN VARCHAR2, pWght IN VARCHAR2, pChars IN VARCHAR2) RETURN VARCHAR2 IS
            l_api_url VARCHAR2(600);
            l_font_face LONG;
            l_url_regex VARCHAR2(9):='\((.+?)\)';
            l_font_url VARCHAR2(500);
            l_font_download BLOB;
            l_font_filename VARCHAR2(100);
            l_clob CLOB;
        BEGIN
            l_api_url:='https://fonts.googleapis.com/css2?family=' || REPLACE(pFamily,' ','+') || ':ital,wght@' || pItal || ',' || pWght
                    || '&display=swap'
                    || '&capability=WOFF2' 
                    || '&text=' || utl_url.escape(pChars,TRUE,'UTF-8');
            pck_api.callGoogleAPI(l_api_url,l_font_face);

            /* GET THE GOOGLE FONT URL FROM THE FONT FACE TO DOWNLOAD THE FONT */
            l_font_filename:=getFontFilename(pFamily, pItal, pWght);
            logDeployment(pWebsiteId, pSiteId, 'Download Google - '||l_font_filename || '(' || LENGTH(pChars) || ' chars)');
            l_font_url:=REGEXP_SUBSTR(l_font_face, l_url_regex, 1, 1, NULL, 1);
            l_font_download:=apex_web_service.make_rest_request_b(p_url=>l_font_url, p_http_method=>'GET');

            addDeploy(pFilename=>l_font_filename, pFileContent=>l_font_download);

            /* REPLACE GOOGLE FONT URL WITH SELF-HOSTED URL */
            l_font_filename:='("/' || l_font_filename || '")';
            l_font_face:=REGEXP_REPLACE(l_font_face,l_url_regex,l_font_filename,1,1);
            RETURN (l_font_face);
        END;

        /*
        ** BUILD SELF-HOSTED FONT FACE RULE FROM A PREVIOUS DEPLOYMENT
        */
        FUNCTION buildFontface(pFamily IN VARCHAR2, pItal IN VARCHAR2, pWght IN VARCHAR2) RETURN VARCHAR2 IS
            l_font_face LONG;
            l_font_filename website_files.file_name%type;
            l_sha1 website_files.sha1%type;
        BEGIN
            l_font_filename:=getFontFilename(pFamily, pItal, pWght);

            l_font_face:=
            '@font-face {' ||
                'font-family:"' || pFamily || '";' ||
                'font-style:' || CASE WHEN pItal='0' THEN 'normal' ELSE 'italic' END || ';' ||
                'font-weight:' || pWght || ';' ||
                'font-stretch:100%;' ||
                'font-display:swap;' ||
                'src: url("/' || l_font_filename || '") format("woff2");' ||
            '}';

            SELECT sha1 INTO l_sha1 FROM website_files WHERE website_id=pWebsiteId AND file_name=l_font_filename;
            l_files.put(l_font_filename, l_sha1);

            RETURN (l_font_face);
        END;

    BEGIN
        /* For logging when called by scheduler */
        pck_sec.g_session_user_id:=pUserId;
        pck_sec.g_website_id:=pWebsiteId;

        pck_codepen.g_nav_labels:=null;

        SELECT 'https://' || domain_name, title, subtitle, contact_email, telephone_number, mobile_number, linkedin_name, instagram_name, SUBSTR(color_primary,2), favicon_asset_id
          INTO l_ssl_url, l_title, l_subtitle, l_contact_email, l_telephone_number, l_mobile_number, l_linkedin_name, l_instagram_name, l_color_primary, l_favicon_asset_id
          FROM website
         WHERE id=pWebsiteId;

        /*
        ** Get all website content into collection
        */
        SELECT parent_article_id, article_id, path_name, collection_type, page_title, page_description, lastmod, word_count, title, subtitle, header_effect, hero_asset_id, contact_email, telephone_number, mobile_number, linkedin_name, instagram_name, promotion, 0, NULL, body_html
          BULK COLLECT INTO l_labels
          FROM
          (
        SELECT wa.article_id parent_article_id, wa.article_id, apex_string_util.get_slug(wa.navigation_label) path_name, wa.collection_type, wa.page_title, wa.page_description, 
            wa.display_order, NVL(a.updated_date,a.created_date) lastmod, a.word_count, w.title, w.subtitle, w.header_effect, w.hero_asset_id, w.contact_email, w.telephone_number, w.mobile_number, w.linkedin_name, w.instagram_name, w.promotion, a.body_html body_html
          FROM website w, website_article wa, article a
         WHERE w.id=pWebsiteId
           AND wa.website_id=w.id 
           AND wa.article_id=a.id
         UNION ALL
        SELECT wa.article_id, a.id, apex_string_util.get_slug(wa.navigation_label) || '/' || apex_string_util.get_slug(utl_i18n.unescape_reference(apex_escape.striphtml(REGEXP_SUBSTR(a.body_html,l_headings_regex,1,1)))),  NULL, NULL, NULL, 
            wa.display_order+NVL(a.display_order/100,0.001),  NVL(a.updated_date,a.created_date) lastmod, a.word_count, w.title, w.subtitle, w.header_effect, w.hero_asset_id, w.contact_email, w.telephone_number, w.mobile_number, w.linkedin_name, w.instagram_name, w.promotion, a.body_html
          FROM website w, website_article wa, article a 
         WHERE w.id=pWebsiteId
           AND wa.website_id=w.id 
           AND a.parent_id=wa.article_id 
           AND wa.collection_type IN ('BLOG','MEDIA')
          )
         ORDER BY display_order, lastmod DESC;
        
        l_json:= new JSON_OBJECT_T;
        l_files:= new JSON_OBJECT_T;
        
        FOR i IN 1..l_labels.COUNT LOOP

            /* For each context collect distinct set of characters styles used in order to optimise font */
            l_body_html:=l_labels(i).body_html;

            /* Remove <code> elements which are always rendered in local monospace font */
            l_body_html:=REGEXP_REPLACE(l_body_html,l_code_regex,null);

            IF (i=1) THEN
                FOR C IN (
                    SELECT 
                        f.id font_id,
                        f.family,
                        CASE WHEN f.wght_end<700 THEN f.wght_end ELSE 700 END wght_bold,
                        CASE WHEN f.wght_start>400 THEN f.wght_start ELSE 400 END wght_normal,
                        wf.context,
                        wf.chars_normal,
                        wf.chars_italic,
                        wf.chars_bold_normal,
                        wf.chars_bold_italic,
                        COUNT(DISTINCT wf.font_id) OVER () nb_fonts,
                        CASE 
                            WHEN wf.context='headings' THEN 
                                '<h1>' || DECODE(wf.ital,1,'<i>') || l_title || DECODE(wf.ital,1,'</i>') || '</h1>'
                            WHEN wf.context='text' THEN 
                                '<p>' || DECODE(wf.ital,1,'<i>') || l_subtitle || DECODE(wf.ital,1,'</i>') || '</p>' ||
                                '<span>' || l_contact_email || '</span>' || 
                                '<span>' || l_telephone_number || '</span>' || 
                                '<span>' || l_mobile_number || '</span>' || 
                                '<span>' || CASE WHEN l_linkedin_name IS NOT NULL THEN 'Let''s Connect' END || '</span>' || 
                                '<span>' || l_instagram_name || '</span>'
                        END html
                      FROM website_font wf, font f
                     WHERE wf.website_id=pWebsiteId
                       AND wf.font_id=f.id
                ) 
                LOOP
                    l_fonts(C.context).font_id:=C.font_id;
                    l_fonts(C.context).family:=C.family;
                    l_fonts(C.context).wght_bold:=C.wght_bold;
                    l_fonts(C.context).wght_normal:=C.wght_normal;
                    l_fonts(C.context).prev_chars_normal:=C.chars_normal;
                    l_fonts(C.context).prev_chars_italic:=C.chars_italic;
                    l_fonts(C.context).prev_chars_bold_normal:=C.chars_bold_normal;
                    l_fonts(C.context).prev_chars_bold_italic:=C.chars_bold_italic;
                    l_body_html:=l_body_html || C.html;
                    l_nb_fonts:=C.nb_fonts;
                END LOOP;
            END IF;

            l_fonts('headings').chars_normal_page:=0;
            l_fonts('headings').chars_italic_page:=0;
            l_fonts('headings').chars_bold_normal_page:=0;
            l_fonts('headings').chars_bold_italic_page:=0;
            l_fonts('text').chars_normal_page:=0;
            l_fonts('text').chars_italic_page:=0;
            l_fonts('text').chars_bold_normal_page:=0;
            l_fonts('text').chars_bold_italic_page:=0;

            n:=REGEXP_COUNT(l_body_html,l_headings_regex);
            IF (n>0) THEN
                FOR j IN 1..n 
                LOOP
                    IF (j=1) THEN
                        l_labels(i).page_title:=utl_i18n.unescape_reference(apex_escape.striphtml(REGEXP_SUBSTR(l_body_html,l_headings_regex,1,j)));
                    END IF;
                    extract_styles(REGEXP_SUBSTR(l_body_html,l_headings_regex,1,j), l_fonts('headings').chars_bold_italic, l_fonts('headings').chars_bold_normal, l_fonts('headings').chars_italic, l_fonts('headings').chars_normal, 
                        l_fonts('headings').chars_bold_italic_page, l_fonts('headings').chars_bold_normal_page, l_fonts('headings').chars_italic_page, l_fonts('headings').chars_normal_page);
                END LOOP;
                l_body_html:=REGEXP_REPLACE(l_body_html,l_headings_regex,null);
            END IF;
            extract_styles(l_body_html, l_fonts('text').chars_bold_italic, l_fonts('text').chars_bold_normal, l_fonts('text').chars_italic, l_fonts('text').chars_normal,
                l_fonts('text').chars_bold_italic_page, l_fonts('text').chars_bold_normal_page, l_fonts('text').chars_italic_page, l_fonts('text').chars_normal_page);                    
            
            /*
            ** MAKE PRELOAD LINKS FOR ALL FONTS USED IN PAGE
            */
            l_context:=l_fonts.FIRST;
            l_font_preload:=NULL;
            WHILE l_context IS NOT NULL LOOP
                IF (l_fonts(l_context).chars_normal_page>0) THEN
                    l_font_preload:=l_font_preload || 
                        '<link rel="preload" href="/' || 
                        getFontFilename(l_fonts(l_context).family, '0', l_fonts(l_context).wght_normal) 
                        || '" as="font" type="font/woff2" />'; 
                END IF;
                IF (l_fonts(l_context).chars_italic_page>0) THEN
                    l_font_preload:=l_font_preload || 
                        '<link rel="preload" href="/' || 
                        getFontFilename(l_fonts(l_context).family, '1', l_fonts(l_context).wght_normal) 
                        || '" as="font" type="font/woff2" />'; 
                END IF;
                IF (l_fonts(l_context).chars_bold_normal_page>0) THEN
                    l_font_preload:=l_font_preload || 
                        '<link rel="preload" href="/' || 
                        getFontFilename(l_fonts(l_context).family, '0', l_fonts(l_context).wght_bold) 
                        || '" as="font" type="font/woff2" />'; 
                END IF;
                IF (l_fonts(l_context).chars_bold_italic_page>0) THEN
                    l_font_preload:=l_font_preload || 
                        '<link rel="preload" href="/' || 
                        getFontFilename(l_fonts(l_context).family, '1', l_fonts(l_context).wght_bold) 
                        || '" as="font" type="font/woff2" />'; 
                END IF;

                l_context:=l_fonts.NEXT(l_context);
            END LOOP;
            l_labels(i).font_preload:=l_font_preload;

            /*
            ** SET IMAGE SRCSET FOR ANY IMAGES INCLUDED IN BODY_HTML
            */
            setImgSrcset(l_labels(i).article_id, l_labels(i).hero_asset_id, l_labels(i).img_count, l_labels(i).body_html);

            IF (l_labels(i).collection_type='BLOG') THEN
                l_is_blog:=TRUE;
                l_is_media:=FALSE;
            ELSIF (l_labels(i).collection_type='MEDIA') THEN
                l_is_media:=TRUE;
                l_is_blog:=FALSE;
            END IF;

            pck_codepen.buildBodyHtml(
                pUserId, 
                pWebsiteId, 
                pEnv,
                pRestUrl,
                l_labels(i).article_id, 
                l_labels(i).collection_type, 
                l_is_media, 
                l_title,
                l_subtitle,
                l_labels(i).header_effect,
                l_labels(i).hero_asset_id,
                l_labels(i).contact_email,
                l_labels(i).telephone_number,
                l_labels(i).mobile_number,
                l_labels(i).linkedin_name,
                l_labels(i).instagram_name,
                l_labels(i).promotion,
                l_labels(i).body_html
            );
        END LOOP;

        /*
        ** Get all font-faces into variable "l_fontfaces"
        ** MERGE headings and text if only one font selected
        */
        logDeployment(pWebsiteId, pSiteId, 'Optimizing FONTS');
        IF (l_nb_fonts=1) THEN
            l_fonts('text').chars_bold_italic:=l_fonts('text').chars_bold_italic || l_fonts('headings').chars_italic;
            l_fonts('text').chars_bold_normal:=l_fonts('text').chars_bold_normal || l_fonts('headings').chars_normal;
            l_fonts.DELETE('headings');
        END IF;
        
        l_context:=l_fonts.FIRST;
        WHILE l_context IS NOT NULL LOOP
            n:=0;
            IF (l_fonts(l_context).chars_normal IS NOT NULL) THEN
                l_fonts(l_context).chars_normal:=chars_used(l_fonts(l_context).chars_normal);
                IF (l_fonts(l_context).chars_normal<>l_fonts(l_context).prev_chars_normal OR l_fonts(l_context).prev_chars_normal IS NULL) THEN
                    l_fontfaces:=l_fontfaces || getFontface(l_fonts(l_context).family, '0', l_fonts(l_context).wght_normal, l_fonts(l_context).chars_normal);
                    n:=n+1;
                ELSE
                    l_fontfaces:=l_fontfaces || buildFontface(l_fonts(l_context).family, '0', l_fonts(l_context).wght_normal);
                END IF;
            END IF;

            IF (l_fonts(l_context).chars_italic IS NOT NULL) THEN
                l_fonts(l_context).chars_italic:=chars_used(l_fonts(l_context).chars_italic);
                IF (l_fonts(l_context).chars_italic<>l_fonts(l_context).prev_chars_italic OR l_fonts(l_context).prev_chars_italic IS NULL) THEN
                    l_fontfaces:=l_fontfaces || getFontface(l_fonts(l_context).family, '1', l_fonts(l_context).wght_normal, l_fonts(l_context).chars_italic);
                    n:=n+1;
                ELSE
                    l_fontfaces:=l_fontfaces || buildFontface(l_fonts(l_context).family, '1', l_fonts(l_context).wght_normal);
                END IF;
            END IF;

            IF (l_fonts(l_context).chars_bold_normal IS NOT NULL) THEN
                l_fonts(l_context).chars_bold_normal:=chars_used(l_fonts(l_context).chars_bold_normal);
                IF (l_fonts(l_context).chars_bold_normal<>l_fonts(l_context).prev_chars_bold_normal OR l_fonts(l_context).prev_chars_bold_normal IS NULL) THEN
                    l_fontfaces:=l_fontfaces || getFontface(l_fonts(l_context).family, '0', l_fonts(l_context).wght_bold, l_fonts(l_context).chars_bold_normal);
                    n:=n+1;
                ELSE
                    l_fontfaces:=l_fontfaces || buildFontface(l_fonts(l_context).family, '0', l_fonts(l_context).wght_bold);
                END IF;
            END IF;

            IF (l_fonts(l_context).chars_bold_italic IS NOT NULL) THEN
                l_fonts(l_context).chars_bold_italic:=chars_used(l_fonts(l_context).chars_bold_italic);
                IF (l_fonts(l_context).chars_bold_italic<>l_fonts(l_context).prev_chars_bold_italic OR l_fonts(l_context).prev_chars_bold_italic IS NULL) THEN
                    l_fontfaces:=l_fontfaces || getFontface(l_fonts(l_context).family, '1', l_fonts(l_context).wght_bold, l_fonts(l_context).chars_bold_italic);
                    n:=n+1;
                ELSE
                    l_fontfaces:=l_fontfaces || buildFontface(l_fonts(l_context).family, '1', l_fonts(l_context).wght_bold);
                END IF;
            END IF;

            IF (n>0) THEN
                UPDATE website_font 
                   SET chars_normal=l_fonts(l_context).chars_normal,
                       chars_italic=l_fonts(l_context).chars_italic,
                       chars_bold_normal=l_fonts(l_context).chars_bold_normal,
                       chars_bold_italic=l_fonts(l_context).chars_bold_italic,
                       updated_date=current_timestamp
                 WHERE website_id=pWebsiteid
                   AND font_id=l_fonts(l_context).font_id
                   AND context=l_context;
            END IF;

            l_context:=l_fonts.NEXT(l_context);
        END LOOP;

        /*
        ** Assemble complete css file from
        ** 1. deploy.css in Apex editor
        ** 2. font face rules
        ** 3. root css
        ** 
        ** Nb. Font-face rules will not exist if website using system-ui
        ** Nb. toptal minifier only accepts form-url-encoded which forces us to restrict content size to <32K
        ** ==> NEED TO OPTIMISE THIS PROCESS
        */
        n:=0;

        /* DETERMINE IF MAIN CSS FILE CHANGED SINCE LAST DEPLOYMENT */
        SELECT CAST(last_updated_on AS TIMESTAMP WITH TIME ZONE)
          INTO l_css_updated_date
          FROM apex_application_static_files
         WHERE application_id=101
           AND file_name='deploy.css';

        SELECT MAX(NVL(sha1_updated,created_date)), MAX(sha1)
          INTO l_css_prev_updated_date, l_sha1
          FROM website_files
         WHERE file_name='css/styles.min.css';

        IF (l_css_updated_date>l_css_prev_updated_date OR l_css_prev_updated_date IS NULL) THEN
            n:=n+1;
        END IF;

        /* DETERMINE IF ROOT CSS CHANGED SINCE LAST DEPLOYMENT */
        SELECT css_root 
          INTO l_css_root_prev
          FROM website
         WHERE id=pWebsiteid;

        l_css_root:=pck_codepen.buildCssRoot(pWebsiteid);

        IF (l_css_root_prev<>l_css_root OR l_css_root_prev IS NULL) THEN
            n:=n+1;
            UPDATE website SET css_root=l_css_root WHERE id=pWebsiteid;
        END IF;

        /* DETERMINE IF FONT FACES CHANGED SINCE LAST DEPLOYMENT */
        FOR C IN (
            SELECT MAX(updated_date) fonts_updated_date FROM website_font WHERE website_id=pWebsiteid
        ) LOOP
            IF (NVL(C.fonts_updated_date,current_timestamp)>NVL(l_css_prev_updated_date,current_timestamp)) THEN
                n:=n+1;
            END IF;
        END LOOP;

        /* n>0 MEANS DEPLOY CSS */
        IF (n>0) THEN
            logDeployment(pWebsiteId, pSiteId, 'Creating CSS');
            FOR C IN (
                SELECT apex_util.blob_to_clob(file_content) file_content 
                  FROM apex_application_static_files
                 WHERE application_id=101
                   AND file_name='deploy.css'
            ) LOOP
                dbms_lob.createtemporary(l_css,true);
                IF (l_fontfaces IS NOT NULL) THEN
                    pck_api.callMinifyCss(l_fontfaces, l_css_minified);
                    dbms_lob.append(l_css,l_css_minified);
                END IF;

                pck_api.callMinifyCss(l_css_root, l_css_minified);
                dbms_lob.append(l_css,l_css_minified);
                
                pck_api.callMinifyCss(C.file_content, l_css_minified);
                dbms_lob.append(l_css,l_css_minified);

                addDeploy('css/styles.min.css', l_css);
                dbms_lob.freetemporary(l_css);
            END LOOP;
        ELSE
            /* NO CHANGE, USE LAST SHA1 */
            l_files.put('css/styles.min.css',l_sha1);
        END IF;

        /* 
        ** The site favicon is an SVG format image file uploaded through the CMS to the Asset table.
        */
        FOR C IN (SELECT cld_cloud_name, resource_type, public_id, format FROM asset WHERE id=l_favicon_asset_id) LOOP
           l_favicon_url:=pck_media.getCloudinaryUrl(C.cld_cloud_name,C.resource_type,C.public_id,C.format, 96) || '.svg';
           l_favicon_url:=REPLACE(l_favicon_url,'q_auto,f_auto','f_auto,w_96,h_96');
        END LOOP;
        /* 
        ** Alternatively use emoji as favicon
        */
        IF (l_favicon_url IS NULL) THEN
            l_favicon_url:=
            'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>&#128516;</text></svg>';
        END IF;

        l_robots:='User-agent: *' || chr(10) || 'Allow: /' || chr(10) || chr(10) || 'Sitemap: ' || l_ssl_url || '/sitemap.xml';

        l_deploy_env:=CASE WHEN pEnv='TEST' THEN 1 WHEN pEnv='LIVE' THEN 3 END;
        WITH data AS
        (
            SELECT 
                SUBSTR(module_name,1,INSTR(module_name,'.')-1) module_name, 
                CASE WHEN pEsmLibrary='live' THEN host_name ELSE REPLACE(host_name,'/live/','/test/') END host_name,
                CASE WHEN pEsmLibrary='live' THEN sha256_live ELSE sha256_test END sha256
            FROM es_modules
            WHERE BITAND(deploy_envs,l_deploy_env)=l_deploy_env
        )
        SELECT json_object(
            'imports' VALUE json_objectagg(module_name VALUE host_name),
            'integrity' VALUE json_objectagg(host_name VALUE sha256)
            returning clob) 
        INTO l_importmap 
        FROM data;

        addDeploy('javascript/importmap.json', l_importmap);

        l_importmap_sha256:=getSha256(l_importmap);
        l_script_sha256:=l_script_sha256 || ' ''' || l_importmap_sha256 || '''';

        /*
        **  ALL PAGES INCLUDE SELF-HOSTED WEB VITALS AND MAIN JAVASCRIPT MODULES
        **  MAIN JAVASCRIPT MODULE IS DOWNLOADED/EXECUTED ON EVENT "DOMContentLoaded"
        */
        FOR C IN (
            SELECT file_name, apex_util.blob_to_clob(file_content) file_content 
              FROM apex_application_static_files 
             WHERE application_id=101
               AND file_name IN ('deploy_main.min.js', 'deploy_web_vitals5.min.js')
        ) LOOP
            addDeploy('javascript/' || C.file_name, C.file_content);
            l_script_sha256:=l_script_sha256 || ' ''' || getSha256(C.file_content) || '''';
        END LOOP;
        l_script_src:=
        'document.addEventListener(''DOMContentLoaded'',()=>{' || 
            'const script = document.createElement(''script'');' ||
            'script.src = "/javascript/deploy_main.min.js";' ||
            'script.type = "module";' ||
            'document.body.appendChild(script);' ||
        '})';
        l_script_sha256:=l_script_sha256 || ' ''' || getSha256(l_script_src) || '''';

        /*
        **  script-src 'strict-dynamic' - allows modules to dynamically create scripts, eg. cloudinary upload widget, CKEditor
        */
        l_headers:=
        '/*' || chr(10) || 
            q'[Content-Security-Policy: default-src 'none';]' ||
            q'[ base-uri 'none';]' ||
            q'[ object-src 'none';]' ||
            CASE WHEN INSTR(l_favicon_url,'cloudinary')>0 THEN
            q'[ img-src 'self' res.cloudinary.com;]'
            ELSE
            q'[ img-src 'self' res.cloudinary.com data:;]'
            END ||
            q'[ media-src res.cloudinary.com;]' ||
            q'[ font-src 'self' fonts.gstatic.com;]' ||
            q'[ style-src 'self' 'unsafe-inline' cdn.ckeditor.com;]' ||
            q'[ script-src 'strict-dynamic' ]' || l_script_sha256 || q'[;]' ||
            q'[ frame-src upload-widget.cloudinary.com  www.youtube.com;]' ||
            q'[ frame-ancestors 'none';]' ||
            q'[ connect-src 'self' ]' || pRestUrl || ';' || chr(10) ||
            q'[X-Content-Type-Options: nosniff]' || chr(10) ||
            q'[X-Frame-Options: SAMEORIGIN]' || chr(10) ||
            q'[Referrer-Policy: no-referrer-when-downgrade]' || chr(10) ||
            q'[Access-Control-Allow-Origin: *]' || chr(10) ||
            q'[Permissions-Policy: microphone=(), geolocation=()]';

        /* 
        ** Build individual website pages
        */
        FOR i IN 1..l_labels.COUNT
        LOOP
            IF (i=1) THEN
                logDeployment(pWebsiteId, pSiteId, 'Building ' || l_labels.COUNT || ' website page' || CASE WHEN l_labels.COUNT>1 THEN 's' END);
                l_sitemap:=
                '<?xml version="1.0" encoding="UTF-8"?>' || 
                '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">';
            END IF;

            l_sitemap:=l_sitemap ||
                '<url><loc>' || l_ssl_url || CASE WHEN i>1 THEN '/' || l_labels(i).path_name END || '</loc><lastmod>' || TO_CHAR(l_labels(i).lastmod,'YYYY-MM-DD') || '</lastmod></url>';
            IF (i=l_labels.COUNT) THEN
                l_sitemap:=l_sitemap || 
                '</urlset>';
            END IF;

            l_page:=
                '<!DOCTYPE HTML>' ||
                '<html lang="en">' ||
                '<head>' ||
                    '<meta charset="UTF-8">' ||
                    '<meta name="viewport" content="width=device-width, initial-scale=1">' ||
                    '<title>' || l_labels(i).page_title || '</title>' ||
                    '<meta name="description" content="' || l_labels(i).page_description || '">' ||
                    '<meta name="author" content="restartnet.com">' ||
                    '<meta name="mobile-web-app-capable" content="yes">' ||
                    CASE WHEN l_labels(i).img_count>0 THEN
                    '<link rel="preconnect" href="https://res.cloudinary.com">'
                    END ||
                    l_labels(i).font_preload ||
                    '<link rel="stylesheet" href="/css/styles.min.css">' ||
                    '<script>' || l_script_src || '</script>' ||
                    '<link rel="icon" type="image/svg+xml" sizes="any" href="' || l_favicon_url || '">' ||
                '</head>' ||
                '<body data-websiteid="' || pWebsiteId || '" data-articleid="' || l_labels(i).article_id || '" data-resturl="' || pRestUrl || '">' || 
                    l_labels(i).body_html || 
                '</body>' ||
            '</html>';

            addDeploy(CASE WHEN i=1 THEN 'index.html' ELSE l_labels(i).path_name || '.html' END, l_page);

        END LOOP;

        /* Build website assets */

        logDeployment(pWebsiteId, pSiteId, 'Building sitemap.xml');
        addDeploy('sitemap.xml', l_sitemap);
        addDeploy('robots.txt', l_robots);

        logDeployment(pWebsiteId, pSiteId, 'Building Content Security Policy');
        addDeploy('_headers', l_headers);

        /*
        ** DEPLOYMENT TO NETLIFY
        ** 1) SEND SHA1 OF ALL FILES IN WEBSITE
        ** 2) NETLIFY RESPONSE INCLUDES ARRAY OF SHA1 REQUIRED TO BE UPLOADED
        ** 3) UPLOAD THE REQUIRED FILES
        */
        l_json.put('files',l_files);

        pck_api.callNetlifyAPI(pUserId=>pUserId, pEndpoint=>'sites/' || pSiteId || '/deploys', pMethod=>'POST', pBody=>l_json.stringify, pData=>l_clob);

        /* NEED THIS FOR ASYNC DEPLOYMENT STATUS MONITORING */
        UPDATE website SET netlify_deploy_id=(SELECT id FROM JSON_TABLE(l_clob, '$' COLUMNS (id))) WHERE id=pWebsiteId;
        COMMIT;

        FOR C IN (SELECT id, sha1 FROM JSON_TABLE(l_clob, '$' COLUMNS (id, NESTED '$.required[*]' COLUMNS (sha1 PATH '$'))) WHERE sha1 IS NOT NULL) LOOP
            logDeployment(pWebsiteId, pSiteId, 'Uploading ' || l_deploy_files(C.sha1).file_name);
            IF (l_deploy_files(C.sha1).file_content IS NOT NULL) THEN
                pck_api.callNetlifyAPI(pUserId=>pUserId, pEndpoint=>'deploys/' || C.id || '/files/' || l_deploy_files(C.sha1).file_name, pMethod=>'PUT', pBody=>l_deploy_files(C.sha1).file_content,pData=>l_clob);
            ELSIF (l_deploy_files(C.sha1).file_content_b IS NOT NULL) THEN
                pck_api.callNetlifyAPI(pUserId=>pUserId, pEndpoint=>'deploys/' || C.id || '/files/' || l_deploy_files(C.sha1).file_name, pMethod=>'PUT', pBody=>l_deploy_files(C.sha1).file_content_b,pData=>l_clob);
            ELSE
                RAISE_APPLICATION_ERROR(-20090,'Logic error - file_content clob and blob both null');
            END IF;
        END LOOP;

        /* UPDATE WEBSITE_FILES WITH THIS DEPLOYMENT */
        l_current_timestamp:=current_timestamp;
        l_sha1:=l_deploy_files.FIRST;
        WHILE l_sha1 IS NOT NULL LOOP
            n:=1;
            BEGIN
                SELECT sha1 
                  INTO l_sha1_prev
                  FROM website_files 
                 WHERE website_id=pWebsiteId 
                   AND file_name=l_deploy_files(l_sha1).file_name;
                EXCEPTION WHEN NO_DATA_FOUND THEN
                    INSERT INTO website_files(website_id, file_name, sha1, md5, content_length)
                    VALUES (pWebsiteId, l_deploy_files(l_sha1).file_name, l_sha1, l_deploy_files(l_sha1).md5, l_deploy_files(l_sha1).content_length);
                    n:=0;
            END;

            IF (n=1) THEN
                IF (l_sha1<>l_sha1_prev) THEN
                    UPDATE website_files
                       SET sha1=l_sha1, 
                           md5=l_deploy_files(l_sha1).md5,
                           content_length=l_deploy_files(l_sha1).content_length,
                           sha1_updated=l_current_timestamp
                     WHERE website_id=pWebsiteId 
                       AND file_name=l_deploy_files(l_sha1).file_name;
                END IF;
            END IF;

            l_sha1:=l_deploy_files.NEXT(l_sha1);
        END LOOP;

        /*
        **  DOGFACE DEPLOYMENT IF USER HAS DOGFACE API KEY AND ESMLIBRARY = 'TEST'
        */
        SELECT COUNT(*) INTO n FROM dual WHERE EXISTS (SELECT null FROM users WHERE id=pUserid AND dogface_api_key IS NOT NULL);
        IF (n=1 AND pEsmLibrary='test') THEN
            SELECT json_arrayagg(
                    json_object(KEY 'path' VALUE '/henk.florentmeijer.com/' || file_name, KEY 'hash' VALUE md5)
                returning clob) 
            INTO l_dogface_requested
            FROM website_files
            WHERE website_id=pWebsiteid;

            pck_api.callDogfaceAPI(pUserId=>pUserId, pEndpoint=>'need-for-upload', pMethod=>'POST', pBody=>l_dogface_requested, pBodyBlob=>l_dogface_empty_blob, pData=>l_dogface_required);

            FOR C IN (
                SELECT df.md5, wf.sha1, wf.file_name 
                  FROM website_files wf, 
                        JSON_TABLE(l_dogface_required, '$[*]' 
                        COLUMNS (md5 varchar2 path '$')) df
                 WHERE df.md5=wf.md5
                   AND instr(wf.file_name,'font')=0
            ) LOOP
                --IF (C.file_name<>'_headers') THEN
                    l_dogface_endpoint:=C.md5 || '/henk.florentmeijer.com/' || C.file_name;
                    IF (l_deploy_files(C.sha1).file_content IS NOT NULL) THEN
                        pck_api.callDogfaceAPI(pUserId=>pUserId, pMethod=>'PUT', pEndpoint=>l_dogface_endpoint, pBody=>l_deploy_files(C.sha1).file_content, pBodyBlob=>l_dogface_empty_blob, pData=>l_clob);
                    ELSE
                        pck_api.callDogfaceAPI(pUserId=>pUserId, pMethod=>'PUT', pEndpoint=>l_dogface_endpoint, pBody=>l_dogface_empty_clob, pBodyBlob=>l_deploy_files(C.sha1).file_content_b, pData=>l_clob);
                    END IF;
                --END IF;
            END LOOP;
        END IF;

        -- DELETE website_files WHERE website_id=pWebsiteId AND (sha1_updated<l_current_timestamp OR sha1_reused<l_current_timestamp);

        EXCEPTION
            WHEN OTHERS THEN
                IF (dbms_lob.istemporary(l_css)=1) THEN
                    dbms_lob.freetemporary(l_css);
                END IF;
                logDeployment(pWebsiteId, pSiteId, SUBSTR(SQLERRM,1,100),'NOK');
                pck_core.log_error;
    END;

    /*
    **  DELETE OLD DEPLOYMENTS FROM NETLIFY SYSTEM
    */
    PROCEDURE runDelete(pUserId IN users.id%type, pWebsiteId IN website.id%type, pSiteId IN website.netlify_site_id%type) IS
        l_clob CLOB;
    BEGIN
        pck_sec.g_session_user_id:=pUserId;
        pck_sec.g_website_id:=pWebsiteId;
        
        pck_api.callNetlifyAPI(pUserId=>pUserId, pEndpoint=>'sites/'|| pSiteId || '/deploys', pMethod=>'GET', pData=>l_clob);
        FOR C IN (
            SELECT id, published_at, MAX(published_at) OVER() last_published_at 
            FROM
                (
                SELECT id, TO_TIMESTAMP_TZ(published_at, 'YYYY-MM-DD"T"HH24:MI:SS.FXFF3TZR') published_at FROM JSON_TABLE(l_clob, '$[*]' COLUMNS (id, published_at))
                )
        )
        LOOP
            IF (C.published_at<C.last_published_at) THEN
                pck_api.callNetlifyAPI(pUserId=>pUserId, pEndpoint=>'sites/'|| pSiteId || '/deploys/' || C.id, pMethod=>'DELETE', pData=>l_clob);
            END IF;
        END LOOP;
    END;

    /*
    ** Delete Github build directory - have to delete files individually before Github removes directory
    */    
    PROCEDURE deleteDirectory(pWebsiteId IN website.id%type, pUserId IN users.id%type) IS
        l_clob CLOB;
        l_domain_name website.domain_name%type;
        l_github CLOB;
        l_json JSON_OBJECT_T;
    BEGIN
        SELECT domain_name INTO l_domain_name FROM website WHERE id=pWebsiteId;
        pck_api.callGithubAPI(pUserId=>pUserId, pEndpoint=>'contents/'||l_domain_name, pMethod=>'GET', pData=>l_clob);
        FOR C IN (SELECT name, sha, message FROM  JSON_TABLE(l_clob FORMAT JSON, '$[*]' COLUMNS (name, sha, message))) LOOP
            IF (C.message IS NOT NULL) THEN 
                pck_core.log(C.message);
                RAISE_APPLICATION_ERROR(-20050,'Error in deleteDirectory - '|| C.message);
            ELSE
                l_json:=JSON_OBJECT_T.parse('{"message":"Commit by PLSQL"}');
                l_json.put('sha',C.sha);
                l_github:=l_json.to_clob; 
                pck_api.callGithubAPI(pUserId=>pUserId, pEndpoint=>'contents/' || l_domain_name || '/'||C.name, pMethod=>'DELETE', pBody=>l_github, pData=>l_clob);
            END IF;
        END LOOP;
        pck_api.resetGithubCurrentBuild(pUserId);
    END;

    /*
    ** Build and deploy AWS SES infrastructure through Terraform by submitting Github action. 
    ** Contact form sending email address must be stored in Apex Administrator description field!
    */
    PROCEDURE deployInfrastructure(pSenderEmail IN VARCHAR2) IS
        l_clob CLOB;
        l_json_clob CLOB;
        l_json JSON_OBJECT_T;
        l_action JSON_OBJECT_T;
    BEGIN
        -- Apex admin user description must hold valid domain name of sending email address
        FOR C IN (SELECT u.id, u.terraform_token, w.description ses_domain_name
                    FROM apex_workspace_apex_users w, users u 
                   WHERE w.email=u.email
                     AND w.is_admin='Yes'
                   ORDER BY date_created
                   FETCH FIRST ROW ONLY) 
        LOOP
            IF (C.ses_domain_name IS NULL) THEN
                dbms_output.put_line('APEX ADMIN USER MUST HAVE DESCRIPTION SET TO DOMAIN NAME OF SENDING EMAIL ADDRESS');
                EXIT;
            END IF;

            /* trigger the deployment using Githib action */          
            l_json:=new JSON_OBJECT_T;
            l_json.put('event_type', 'trigger_build_infra');

            l_action:=new JSON_OBJECT_T;
            l_action.put('from_email', pSenderEmail||'@'||C.ses_domain_name); --'contact.form@adfreesites.com'
            l_action.put('terraform_token', C.terraform_token);
            l_json.put('client_payload', l_action);

            --l_clob := apex_web_service.make_rest_request(p_url=>'https://api.github.com/repos/'|| C.deploy_repo || '/dispatches' ,p_http_method=>'POST',p_body=>l_json.stringify);

            /* nb; Github API 'dispatches' endpoint does not send a response */
            l_json_clob:=l_json.stringify;
            pck_api.callGithubAPI(pUserId=>C.id, pEndpoint=>'dispatches', pMethod=>'POST', pBody=>l_json_clob, pData=>l_clob);

        END LOOP;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;

/*
**  RUN this after deploying infrastructure for AWS enabling Amazon Simple Email Service
**  Updates the Admin user's "aws gateway url" and "api key" required for SES send mail service
*/
    PROCEDURE setTerraformApikey IS
        l_domain_name website.domain_name%type; 
        l_admin_id users.id%type;
        l_aws_gateway_url VARCHAR2(200);
        l_api_key varchar2(40);
        l_api_key_link VARCHAR2(100);
        l_clob CLOB;
    BEGIN
        SELECT u.id, SUBSTR(w.description,1,INSTR(w.description,'.')-1)
          INTO l_admin_id, l_domain_name
          FROM apex_workspace_apex_users w, users u 
         WHERE w.email=u.email
           AND w.is_admin='Yes'
         ORDER BY date_created
         FETCH FIRST ROW ONLY;

        pck_api.callTerraformAPI(pUserId=>null, pEndpoint=>'api/v2/organizations/Florent/workspaces/Mark_CMS', pMethod=>'GET', pData=>l_clob);

        FOR C IN (SELECT related FROM JSON_TABLE(l_clob, '$.data.relationships.outputs.links' COLUMNS (related))) LOOP
            pck_api.callTerraformAPI(pUserId=>null, pEndpoint=>C.related, pMethod=>'GET', pData=>l_clob);

            /* invoke_url */
            FOR C1 IN (SELECT value FROM JSON_TABLE(l_clob, '$.data[*]' COLUMNS (name PATH '$.attributes.name', value PATH '$.attributes.value')) WHERE name='invoke_url') LOOP
                l_aws_gateway_url:=C1.value || 'send/' || l_domain_name;
            END LOOP;

            /* ses_dkim_tokens */
            dbms_output.put_line('FETCHING DKIM TOKENS');
            FOR C1 IN (SELECT dkim FROM JSON_TABLE(l_clob, '$.data[*]' COLUMNS (name PATH '$.attributes.name', NESTED PATH '$.attributes.value[*]' COLUMNS (dkim VARCHAR2(40) PATH '$'))) WHERE name='ses_dkim_tokens') LOOP
                dbms_output.put_line('ses_dkim_tokens:'||C1.dkim);
            END LOOP;

            /* api_key */
            FOR C1 IN (SELECT api_key_link FROM JSON_TABLE(l_clob, '$.data[*]' COLUMNS (api_key_link PATH '$.links.self', name PATH '$.attributes.name', value PATH '$.attributes.value')) WHERE name='api_key') LOOP
                l_api_key_link:=C1.api_key_link;
            END LOOP;
            pck_api.callTerraformAPI(pUserId=>null, pEndpoint=>l_api_key_link, pMethod=>'GET', pData=>l_clob);
            FOR C1 IN (SELECT value FROM JSON_TABLE(l_clob, '$.data' COLUMNS (value PATH '$.attributes.value'))) LOOP
                l_api_key:=C1.value;
            END LOOP;
        END LOOP;

        IF (l_aws_gateway_url IS NOT NULL AND l_api_key IS NOT NULL) THEN
            UPDATE users 
               SET terraform_aws_gateway_url=l_aws_gateway_url, 
                   terraform_api_key=l_api_key
             WHERE id=l_admin_id;

            dbms_output.put_line('TERRAFORM API_KEY UPDATED SUCESSFULLY');
            dbms_output.put_line('TERRAFORM AWS_GATEWAY_URL UPDATED SUCESSFULLY');
            RETURN;
        END IF;

        IF (l_api_key IS NULL) THEN
            dbms_output.put_line('FAILED TO UPDATE TERRAFORM API_KEY');
        END IF;

        IF (l_aws_gateway_url IS NULL) THEN
            dbms_output.put_line('FAILED TO UPDATE TERRAFORM AWS_GATEWAY_URL');
        END IF;
    END;
       
end;
/